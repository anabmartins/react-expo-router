{"ast":null,"code":"function findTopStateForTarget(state) {\n  var current = state;\n  while (((_current = current) == null ? void 0 : (_current$routes = _current.routes) == null ? void 0 : _current$routes[((_current2 = current) == null ? void 0 : (_current2$routes = _current2.routes) == null ? void 0 : _current2$routes.length) - 1].state) != null) {\n    var _current, _current$routes, _current2, _current2$routes, _current3, _current4;\n    current = (_current3 = current) == null ? void 0 : _current3.routes[((_current4 = current) == null ? void 0 : _current4.routes.length) - 1].state;\n  }\n  return current;\n}\nexport function findTopRouteForTarget(state) {\n  var _nextState$routes;\n  var nextState = findTopStateForTarget(state);\n  return (_nextState$routes = nextState.routes) == null ? void 0 : _nextState$routes[nextState.routes.length - 1];\n}\nexport function isMovingToSiblingRoute(rootState, targetState) {\n  var current = targetState;\n  var currentRoot = rootState;\n  var _loop = function _loop() {\n    var _current7, _current7$routes, _current8, _current8$routes, _nextRoute$state, _currentRoot$index, _currentRoot, _currentRoot2, _currentRoot2$routes, _currentRoot2$routes$;\n    var nextRoute = (_current7 = current) == null ? void 0 : (_current7$routes = _current7.routes) == null ? void 0 : _current7$routes[((_current8 = current) == null ? void 0 : (_current8$routes = _current8.routes) == null ? void 0 : _current8$routes.length) - 1];\n    if ((_nextRoute$state = nextRoute.state) != null && _nextRoute$state.routes.length && !currentRoot) {\n      return {\n        v: false\n      };\n    }\n    var absCurrent = currentRoot.routes[(_currentRoot$index = (_currentRoot = currentRoot) == null ? void 0 : _currentRoot.index) != null ? _currentRoot$index : 0];\n    if (absCurrent.name !== nextRoute.name) {\n      return {\n        v: false\n      };\n    }\n    currentRoot = (_currentRoot2 = currentRoot) == null ? void 0 : (_currentRoot2$routes = _currentRoot2.routes) == null ? void 0 : (_currentRoot2$routes$ = _currentRoot2$routes.find(function (route) {\n      return route.name === nextRoute.name;\n    })) == null ? void 0 : _currentRoot2$routes$.state;\n    current = nextRoute.state;\n  };\n  while (((_current5 = current) == null ? void 0 : (_current5$routes = _current5.routes) == null ? void 0 : _current5$routes[((_current6 = current) == null ? void 0 : (_current6$routes = _current6.routes) == null ? void 0 : _current6$routes.length) - 1].state) != null) {\n    var _current5, _current5$routes, _current6, _current6$routes;\n    var _ret = _loop();\n    if (typeof _ret === \"object\") return _ret.v;\n  }\n  return true;\n}\nexport function getQualifiedStateForTopOfTargetState(rootState, targetState) {\n  var current = targetState;\n  var currentRoot = rootState;\n  var _loop2 = function _loop2() {\n    var _current11, _current11$routes, _current12, _current12$routes, _currentRoot3, _currentRoot3$routes, _currentRoot3$routes$;\n    var nextRoute = (_current11 = current) == null ? void 0 : (_current11$routes = _current11.routes) == null ? void 0 : _current11$routes[((_current12 = current) == null ? void 0 : (_current12$routes = _current12.routes) == null ? void 0 : _current12$routes.length) - 1];\n    var nextCurrentRoot = (_currentRoot3 = currentRoot) == null ? void 0 : (_currentRoot3$routes = _currentRoot3.routes) == null ? void 0 : (_currentRoot3$routes$ = _currentRoot3$routes.find(function (route) {\n      return route.name === nextRoute.name;\n    })) == null ? void 0 : _currentRoot3$routes$.state;\n    if (nextCurrentRoot == null) {\n      return {\n        v: currentRoot\n      };\n    } else {\n      currentRoot = nextCurrentRoot;\n    }\n    current = nextRoute.state;\n  };\n  while (((_current9 = current) == null ? void 0 : (_current9$routes = _current9.routes) == null ? void 0 : _current9$routes[((_current10 = current) == null ? void 0 : (_current10$routes = _current10.routes) == null ? void 0 : _current10$routes.length) - 1].state) != null) {\n    var _current9, _current9$routes, _current10, _current10$routes;\n    var _ret2 = _loop2();\n    if (typeof _ret2 === \"object\") return _ret2.v;\n  }\n  return currentRoot;\n}\nexport function getEarliestMismatchedRoute(rootState, actionParams) {\n  var _actionParams$name;\n  var actionName = (_actionParams$name = actionParams.name) != null ? _actionParams$name : actionParams.screen;\n  if (!(rootState != null && rootState.routes) || rootState.index == null) {\n    return {\n      name: actionName,\n      type: \"stack\"\n    };\n  }\n  var nextCurrentRoot = rootState.routes[rootState.index];\n  if (actionName === nextCurrentRoot.name) {\n    if (!actionParams.params) {\n      return null;\n    }\n    return getEarliestMismatchedRoute(nextCurrentRoot.state, actionParams.params);\n  }\n  return {\n    name: actionName,\n    params: actionParams.params,\n    type: rootState.type\n  };\n}","map":{"version":3,"names":["findTopStateForTarget","state","current","_current","_current$routes","routes","_current2","_current2$routes","length","_current3","_current4","findTopRouteForTarget","_nextState$routes","nextState","isMovingToSiblingRoute","rootState","targetState","currentRoot","_loop","_current7","_current7$routes","_current8","_current8$routes","_nextRoute$state","_currentRoot$index","_currentRoot","_currentRoot2","_currentRoot2$routes","_currentRoot2$routes$","nextRoute","v","absCurrent","index","name","find","route","_current5","_current5$routes","_current6","_current6$routes","_ret","getQualifiedStateForTopOfTargetState","_loop2","_current11","_current11$routes","_current12","_current12$routes","_currentRoot3","_currentRoot3$routes","_currentRoot3$routes$","nextCurrentRoot","_current9","_current9$routes","_current10","_current10$routes","_ret2","getEarliestMismatchedRoute","actionParams","_actionParams$name","actionName","screen","type","params"],"sources":["/home/martz/GitHub/react-expo-router/NavTabs/node_modules/expo-router/src/link/stateOperations.ts"],"sourcesContent":["import {\n  InitialState,\n  NavigationState,\n  ParamListBase,\n  getActionFromState,\n} from \"@react-navigation/native\";\n\nimport { ResultState } from \"../fork/getStateFromPath\";\n\nexport type NavigateAction = Extract<\n  ReturnType<typeof getActionFromState>,\n  { type: \"NAVIGATE\" }\n> & {\n  payload: NavigateActionParams;\n};\n\nexport type NavigateActionParams = {\n  params?: NavigateActionParams;\n  path: string;\n  initial: boolean;\n  screen: string;\n  name?: string;\n};\n\n// Get the last state for a given target state (generated from a path).\nfunction findTopStateForTarget(state: ResultState) {\n  let current: Partial<InitialState> | undefined = state;\n\n  while (current?.routes?.[current?.routes?.length - 1].state != null) {\n    current = current?.routes[current?.routes.length - 1].state;\n  }\n\n  return current;\n}\n\n/** Return the absolute last route to move to. */\nexport function findTopRouteForTarget(state: ResultState) {\n  const nextState = findTopStateForTarget(state)!;\n  // Ensure we get the last route to prevent returning the initial route.\n  return nextState.routes?.[nextState.routes.length - 1]!;\n}\n\n/** @returns true if moving to a sibling inside the same navigator. */\nexport function isMovingToSiblingRoute(\n  rootState: InitialState,\n  targetState: ResultState\n): boolean {\n  let current: InitialState | undefined = targetState;\n  let currentRoot: InitialState | undefined = rootState;\n\n  while (current?.routes?.[current?.routes?.length - 1].state != null) {\n    const nextRoute: any = current?.routes?.[current?.routes?.length - 1];\n\n    if (\n      // Has more\n      nextRoute.state?.routes.length &&\n      // No match\n      !currentRoot\n    ) {\n      return false;\n    }\n\n    const absCurrent = currentRoot!.routes[currentRoot?.index ?? 0];\n\n    if (absCurrent.name !== nextRoute.name) {\n      return false;\n    }\n\n    currentRoot = currentRoot?.routes?.find(\n      (route) => route.name === nextRoute.name\n    )?.state;\n\n    current = nextRoute.state;\n  }\n\n  return true;\n}\n\n// Given the root state and a target state from `getStateFromPath`,\n// return the root state containing the highest target route matching the root state.\n// This can be used to determine what type of navigator action should be used.\nexport function getQualifiedStateForTopOfTargetState(\n  rootState: InitialState,\n  targetState: ResultState\n) {\n  let current: InitialState | undefined = targetState;\n  let currentRoot: InitialState | undefined = rootState;\n\n  while (current?.routes?.[current?.routes?.length - 1].state != null) {\n    const nextRoute: any = current?.routes?.[current?.routes?.length - 1];\n\n    const nextCurrentRoot: InitialState | undefined = currentRoot?.routes?.find(\n      (route) => route.name === nextRoute.name\n    )?.state;\n\n    if (nextCurrentRoot == null) {\n      return currentRoot;\n      // Not sure what to do -- we're tracking against the assumption that\n      // all routes in the target state are in the root state\n      // currentRoot = undefined;\n    } else {\n      currentRoot = nextCurrentRoot;\n    }\n\n    current = nextRoute.state;\n  }\n\n  return currentRoot;\n}\n\n// Given the root state and a target state from `getStateFromPath`,\n// return the root state containing the highest target route matching the root state.\n// This can be used to determine what type of navigator action should be used.\nexport function getEarliestMismatchedRoute<T extends ParamListBase>(\n  rootState: NavigationState<T> | undefined,\n  actionParams: NavigateActionParams\n): { name: string; params?: any; type?: string } | null {\n  const actionName = actionParams.name ?? actionParams.screen;\n  if (!rootState?.routes || rootState.index == null) {\n    // This should never happen where there's more action than state.\n    return {\n      name: actionName,\n      type: \"stack\",\n    };\n  }\n\n  const nextCurrentRoot = rootState.routes[rootState.index];\n  if (actionName === nextCurrentRoot.name) {\n    if (!actionParams.params) {\n      // All routes match all the way up, no change required.\n      return null;\n    }\n\n    return getEarliestMismatchedRoute(\n      // @react-navigation/native types this as NavigationState | Partial<NavigationState> | undefined\n      // In our usage, it's always a NavigationState | undefined\n      nextCurrentRoot.state as NavigationState<T> | undefined,\n      actionParams.params\n    );\n  }\n\n  // There's a selected state but it doesn't match the action state\n  // this is now the lowest point of change.\n  return {\n    name: actionName,\n    params: actionParams.params,\n    type: rootState.type,\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}