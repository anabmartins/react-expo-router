{"ast":null,"code":"import _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nimport { getNameFromFilePath, matchDeepDynamicRouteName, matchDynamicName, matchGroupName, removeSupportedExtensions, stripGroupSegmentsFromPath, stripInvisibleSegmentsFromPath } from \"./matchers\";\nexport function getRecursiveTree(files) {\n  var tree = {\n    name: \"\",\n    children: [],\n    parents: [],\n    node: null\n  };\n  for (var file of files) {\n    var parts = file.normalizedName.split(\"/\");\n    var currentNode = tree;\n    var _loop = function _loop() {\n      var part = parts[i];\n      if (i === parts.length - 1 && part === \"_layout\") {\n        if (currentNode.node) {\n          var overwritten = currentNode.node.contextKey;\n          throw new Error(\"Higher priority Layout Route \\\"\" + file.contextKey + \"\\\" overriding redundant Layout Route \\\"\" + overwritten + \"\\\". Remove the Layout Route \\\"\" + overwritten + \"\\\" to fix this.\");\n        }\n        return \"continue\";\n      }\n      var existing = currentNode.children.find(function (item) {\n        return item.name === part;\n      });\n      if (existing) {\n        currentNode = existing;\n      } else {\n        var newNode = {\n          name: part,\n          children: [],\n          parents: [].concat(_toConsumableArray(currentNode.parents), [currentNode.name]),\n          node: null\n        };\n        currentNode.children.push(newNode);\n        currentNode = newNode;\n      }\n    };\n    for (var i = 0; i < parts.length; i++) {\n      var _ret = _loop();\n      if (_ret === \"continue\") continue;\n    }\n    currentNode.node = file;\n  }\n  if (process.env.NODE_ENV !== \"production\") {\n    assertDeprecatedFormat(tree);\n  }\n  return tree;\n}\nfunction assertDeprecatedFormat(tree) {\n  for (var child of tree.children) {\n    if (child.node && child.children.length && !child.node.normalizedName.endsWith(\"_layout\")) {\n      var ext = child.node.contextKey.split(\".\").pop();\n      throw new Error(\"Using deprecated Layout Route format: Move `./app/\" + child.node.normalizedName + \".\" + ext + \"` to `./app/\" + child.node.normalizedName + \"/_layout.\" + ext + \"`\");\n    }\n    assertDeprecatedFormat(child);\n  }\n}\nfunction getTreeNodesAsRouteNodes(nodes) {\n  return nodes.map(function (node) {\n    return treeNodeToRouteNode(node);\n  }).flat().filter(Boolean);\n}\nexport function generateDynamicFromSegment(name) {\n  var deepDynamicName = matchDeepDynamicRouteName(name);\n  var dynamicName = deepDynamicName != null ? deepDynamicName : matchDynamicName(name);\n  return dynamicName ? {\n    name: dynamicName,\n    deep: !!deepDynamicName\n  } : null;\n}\nexport function generateDynamic(name) {\n  var description = name.split(\"/\").map(function (segment) {\n    return generateDynamicFromSegment(segment);\n  }).filter(Boolean);\n  return description.length === 0 ? null : description;\n}\nfunction collapseRouteSegments(route) {\n  return stripGroupSegmentsFromPath(route.replace(/\\/index$/, \"\"));\n}\nfunction getDefaultInitialRoute(node, name) {\n  return node.children.find(function (node) {\n    return collapseRouteSegments(node.route) === name;\n  });\n}\nfunction applyDefaultInitialRouteName(node) {\n  var _node$children, _getDefaultInitialRou;\n  var groupName = matchGroupName(node.route);\n  if (!((_node$children = node.children) != null && _node$children.length)) {\n    return node;\n  }\n  var initialRouteName = groupName ? (_getDefaultInitialRou = getDefaultInitialRoute(node, groupName)) == null ? void 0 : _getDefaultInitialRou.route : undefined;\n  var loaded = node.loadRoute();\n  if (loaded.unstable_settings) {\n    var _loaded$unstable_sett;\n    initialRouteName = (_loaded$unstable_sett = loaded.unstable_settings.initialRouteName) != null ? _loaded$unstable_sett : initialRouteName;\n    if (groupName) {\n      var _loaded$unstable_sett2, _loaded$unstable_sett3;\n      var groupSpecificInitialRouteName = (_loaded$unstable_sett2 = loaded.unstable_settings) == null ? void 0 : (_loaded$unstable_sett3 = _loaded$unstable_sett2[groupName]) == null ? void 0 : _loaded$unstable_sett3.initialRouteName;\n      initialRouteName = groupSpecificInitialRouteName != null ? groupSpecificInitialRouteName : initialRouteName;\n    }\n  }\n  return _objectSpread(_objectSpread({}, node), {}, {\n    initialRouteName: initialRouteName\n  });\n}\nfunction cloneGroupRoute(node, _ref) {\n  var nextName = _ref.name;\n  var groupName = \"(\" + nextName + \")\";\n  var parts = node.contextKey.split(\"/\");\n  parts[parts.length - 2] = groupName;\n  return _objectSpread(_objectSpread({}, node), {}, {\n    route: groupName,\n    contextKey: parts.join(\"/\")\n  });\n}\nfunction folderNodeToRouteNode(_ref2) {\n  var name = _ref2.name,\n    children = _ref2.children;\n  if (!children.length) {\n    return null;\n  }\n  return getTreeNodesAsRouteNodes(children.map(function (child) {\n    return _objectSpread(_objectSpread({}, child), {}, {\n      name: [name, child.name].filter(Boolean).join(\"/\")\n    });\n  }));\n}\nfunction fileNodeToRouteNode(tree) {\n  var name = tree.name,\n    node = tree.node,\n    children = tree.children;\n  if (!node) throw new Error(\"node must be defined\");\n  var dynamic = generateDynamic(name);\n  var groupName = matchGroupName(name);\n  var multiGroup = groupName == null ? void 0 : groupName.includes(\",\");\n  var clones = multiGroup ? groupName.split(\",\").map(function (v) {\n    return {\n      name: v.trim()\n    };\n  }) : null;\n  if (clones) {\n    var names = new Set();\n    for (var clone of clones) {\n      if (names.has(clone.name)) {\n        throw new Error(\"Array syntax cannot contain duplicate group name \\\"\" + clone.name + \"\\\" in \\\"\" + node.contextKey + \"\\\".\");\n      }\n      names.add(clone.name);\n    }\n  }\n  var output = {\n    loadRoute: node.loadRoute,\n    route: name,\n    contextKey: node.contextKey,\n    children: getTreeNodesAsRouteNodes(children),\n    dynamic: dynamic\n  };\n  if (Array.isArray(clones)) {\n    return clones.map(function (clone) {\n      return applyDefaultInitialRouteName(cloneGroupRoute(_objectSpread({}, output), clone));\n    });\n  }\n  return [applyDefaultInitialRouteName({\n    loadRoute: node.loadRoute,\n    route: name,\n    contextKey: node.contextKey,\n    children: getTreeNodesAsRouteNodes(children),\n    dynamic: dynamic\n  })];\n}\nfunction treeNodeToRouteNode(tree) {\n  if (tree.node) {\n    return fileNodeToRouteNode(tree);\n  }\n  return folderNodeToRouteNode(tree);\n}\nfunction contextModuleToFileNodes(contextModule) {\n  var files = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : contextModule.keys();\n  var nodes = files.map(function (key) {\n    try {\n      if (process.env.NODE_ENV === \"development\") {\n        if (\"sync\" === \"sync\") {\n          var _contextModule;\n          if (!((_contextModule = contextModule(key)) != null && _contextModule.default)) {\n            return null;\n          }\n        }\n      }\n      var node = {\n        loadRoute: function loadRoute() {\n          return contextModule(key);\n        },\n        normalizedName: getNameFromFilePath(key),\n        contextKey: key\n      };\n      return node;\n    } catch (error) {\n      console.warn('Error loading route \"' + key + '\"', error);\n    }\n    return null;\n  });\n  return nodes.filter(Boolean);\n}\nfunction hasCustomRootLayoutNode(routes) {\n  if (routes.length !== 1) {\n    return false;\n  }\n  var route = routes[0];\n  if (route.route === \"\" && route.contextKey.match(/^\\.\\/_layout\\.([jt]sx?)$/)) {\n    return true;\n  }\n  return false;\n}\nfunction treeNodesToRootRoute(treeNode) {\n  var routes = treeNodeToRouteNode(treeNode);\n  return withOptionalRootLayout(routes);\n}\nfunction processKeys(files, options) {\n  var ignore = options.ignore;\n  return files.filter(function (file) {\n    return !(ignore != null && ignore.some(function (pattern) {\n      return pattern.test(file);\n    }));\n  });\n}\nexport function assertDuplicateRoutes(filenames) {\n  if (process.env.NODE_ENV === \"production\") {\n    return;\n  }\n  var duplicates = filenames.map(function (filename) {\n    return removeSupportedExtensions(filename);\n  }).reduce(function (acc, filename) {\n    acc[filename] = acc[filename] ? acc[filename] + 1 : 1;\n    return acc;\n  }, {});\n  Object.entries(duplicates).forEach(function (_ref3) {\n    var _ref4 = _slicedToArray(_ref3, 2),\n      filename = _ref4[0],\n      count = _ref4[1];\n    if (count > 1) {\n      throw new Error(\"Multiple files match the route name \\\"\" + filename + \"\\\".\");\n    }\n  });\n}\nexport function getRoutes(contextModule, options) {\n  var route = getExactRoutes(contextModule, options);\n  if (!route) {\n    return null;\n  }\n  appendSitemapRoute(route);\n  appendUnmatchedRoute(route);\n  return route;\n}\nexport function getRoutesAsync(_x, _x2) {\n  return _getRoutesAsync.apply(this, arguments);\n}\nfunction _getRoutesAsync() {\n  _getRoutesAsync = _asyncToGenerator(function* (contextModule, options) {\n    var route = yield getExactRoutesAsync(contextModule, options);\n    if (!route) {\n      return null;\n    }\n    appendSitemapRoute(route);\n    appendUnmatchedRoute(route);\n    return route;\n  });\n  return _getRoutesAsync.apply(this, arguments);\n}\nfunction getIgnoreList(options) {\n  var _options$ignore;\n  var ignore = [/^\\.\\/\\+html\\.[tj]sx?$/].concat(_toConsumableArray((_options$ignore = options == null ? void 0 : options.ignore) != null ? _options$ignore : []));\n  return ignore;\n}\nexport function getExactRoutes(contextModule, options) {\n  var treeNodes = contextModuleToTree(contextModule, options);\n  var route = treeNodesToRootRoute(treeNodes);\n  return route || null;\n}\nfunction contextModuleToTree(contextModule, options) {\n  var allowed = processKeys(contextModule.keys(), _objectSpread(_objectSpread({}, options), {}, {\n    ignore: getIgnoreList(options)\n  }));\n  assertDuplicateRoutes(allowed);\n  var files = contextModuleToFileNodes(contextModule, allowed);\n  return getRecursiveTree(files);\n}\nexport function getExactRoutesAsync(_x3, _x4) {\n  return _getExactRoutesAsync.apply(this, arguments);\n}\nfunction _getExactRoutesAsync() {\n  _getExactRoutesAsync = _asyncToGenerator(function* (contextModule, options) {\n    var treeNodes = contextModuleToTree(contextModule, options);\n    var route = treeNodesToRootRoute(treeNodes);\n    return route || null;\n  });\n  return _getExactRoutesAsync.apply(this, arguments);\n}\nfunction appendSitemapRoute(routes) {\n  if (!routes.children.length || routes.children.some(function (route) {\n    return route.route === \"_sitemap\";\n  })) {\n    return routes;\n  }\n  var _require = require(\"./views/Sitemap\"),\n    Sitemap = _require.Sitemap,\n    getNavOptions = _require.getNavOptions;\n  routes.children.push({\n    loadRoute: function loadRoute() {\n      return {\n        default: Sitemap,\n        getNavOptions: getNavOptions\n      };\n    },\n    route: \"_sitemap\",\n    contextKey: \"./_sitemap.tsx\",\n    generated: true,\n    internal: true,\n    dynamic: null,\n    children: []\n  });\n  return routes;\n}\nfunction appendUnmatchedRoute(routes) {\n  var userDefinedDynamicRoute = getUserDefinedDeepDynamicRoute(routes);\n  if (!userDefinedDynamicRoute) {\n    routes.children.push({\n      loadRoute: function loadRoute() {\n        return {\n          default: require(\"./views/Unmatched\").Unmatched\n        };\n      },\n      route: \"[...404]\",\n      contextKey: \"./[...404].tsx\",\n      dynamic: [{\n        name: \"404\",\n        deep: true\n      }],\n      children: [],\n      generated: true,\n      internal: true\n    });\n  }\n  return routes;\n}\nexport function getUserDefinedDeepDynamicRoute(routes) {\n  for (var route of (_routes$children = routes.children) != null ? _routes$children : []) {\n    var _routes$children;\n    if (route.generated) continue;\n    var opaqueRoute = stripInvisibleSegmentsFromPath(route.route);\n    var isDeepDynamic = matchDeepDynamicRouteName(opaqueRoute);\n    if (isDeepDynamic) {\n      return route;\n    }\n    if (matchGroupName(route.route)) {\n      var child = getUserDefinedDeepDynamicRoute(route);\n      if (child) {\n        return child;\n      }\n    }\n  }\n  return null;\n}\nfunction withOptionalRootLayout(routes) {\n  if (!(routes != null && routes.length)) {\n    return null;\n  }\n  if (hasCustomRootLayoutNode(routes)) {\n    return routes[0];\n  }\n  return {\n    loadRoute: function loadRoute() {\n      return {\n        default: require(\"./views/Navigator\").DefaultNavigator\n      };\n    },\n    contextKey: \"./_layout.tsx\",\n    route: \"\",\n    generated: true,\n    dynamic: null,\n    children: routes\n  };\n}","map":{"version":3,"names":["getNameFromFilePath","matchDeepDynamicRouteName","matchDynamicName","matchGroupName","removeSupportedExtensions","stripGroupSegmentsFromPath","stripInvisibleSegmentsFromPath","getRecursiveTree","files","tree","name","children","parents","node","file","parts","normalizedName","split","currentNode","_loop","part","i","length","overwritten","contextKey","Error","existing","find","item","newNode","concat","_toConsumableArray","push","_ret","process","env","NODE_ENV","assertDeprecatedFormat","child","endsWith","ext","pop","getTreeNodesAsRouteNodes","nodes","map","treeNodeToRouteNode","flat","filter","Boolean","generateDynamicFromSegment","deepDynamicName","dynamicName","deep","generateDynamic","description","segment","collapseRouteSegments","route","replace","getDefaultInitialRoute","applyDefaultInitialRouteName","_node$children","_getDefaultInitialRou","groupName","initialRouteName","undefined","loaded","loadRoute","unstable_settings","_loaded$unstable_sett","_loaded$unstable_sett2","_loaded$unstable_sett3","groupSpecificInitialRouteName","_objectSpread","cloneGroupRoute","_ref","nextName","join","folderNodeToRouteNode","_ref2","fileNodeToRouteNode","dynamic","multiGroup","includes","clones","v","trim","names","Set","clone","has","add","output","Array","isArray","contextModuleToFileNodes","contextModule","arguments","keys","key","_contextModule","default","error","console","warn","hasCustomRootLayoutNode","routes","match","treeNodesToRootRoute","treeNode","withOptionalRootLayout","processKeys","options","ignore","some","pattern","test","assertDuplicateRoutes","filenames","duplicates","filename","reduce","acc","Object","entries","forEach","_ref3","_ref4","_slicedToArray","count","getRoutes","getExactRoutes","appendSitemapRoute","appendUnmatchedRoute","getRoutesAsync","_x","_x2","_getRoutesAsync","apply","_asyncToGenerator","getExactRoutesAsync","getIgnoreList","_options$ignore","treeNodes","contextModuleToTree","allowed","_x3","_x4","_getExactRoutesAsync","_require","require","Sitemap","getNavOptions","generated","internal","userDefinedDynamicRoute","getUserDefinedDeepDynamicRoute","Unmatched","_routes$children","opaqueRoute","isDeepDynamic","DefaultNavigator"],"sources":["/home/martz/GitHub/react-expo-router/NavTabs/node_modules/expo-router/src/getRoutes.ts"],"sourcesContent":["import type { DynamicConvention, RouteNode } from \"./Route\";\nimport {\n  getNameFromFilePath,\n  matchDeepDynamicRouteName,\n  matchDynamicName,\n  matchGroupName,\n  removeSupportedExtensions,\n  stripGroupSegmentsFromPath,\n  stripInvisibleSegmentsFromPath,\n} from \"./matchers\";\nimport type { RequireContext } from \"./types\";\n\nexport type FileNode = Pick<RouteNode, \"contextKey\" | \"loadRoute\"> & {\n  /** Like `(tab)/index` */\n  normalizedName: string;\n};\n\ntype TreeNode = {\n  name: string;\n  children: TreeNode[];\n  parents: string[];\n  /** null when there is no file in a folder. */\n  node: FileNode | null;\n};\n\ntype Options = {\n  ignore?: RegExp[];\n};\n\n/** Convert a flat map of file nodes into a nested tree of files. */\nexport function getRecursiveTree(files: FileNode[]): TreeNode {\n  const tree = {\n    name: \"\",\n    children: [],\n    parents: [],\n    node: null,\n  };\n\n  for (const file of files) {\n    // ['(tab)', 'settings', '[...another]']\n    const parts = file.normalizedName.split(\"/\");\n    let currentNode: TreeNode = tree;\n    for (let i = 0; i < parts.length; i++) {\n      const part = parts[i];\n\n      if (i === parts.length - 1 && part === \"_layout\") {\n        if (currentNode.node) {\n          const overwritten = currentNode.node.contextKey;\n          throw new Error(\n            `Higher priority Layout Route \"${file.contextKey}\" overriding redundant Layout Route \"${overwritten}\". Remove the Layout Route \"${overwritten}\" to fix this.`\n          );\n        }\n        continue;\n      }\n\n      const existing = currentNode.children.find((item) => item.name === part);\n      if (existing) {\n        currentNode = existing;\n      } else {\n        const newNode: TreeNode = {\n          name: part,\n          children: [],\n          parents: [...currentNode.parents, currentNode.name],\n          node: null,\n        };\n        currentNode.children.push(newNode);\n        currentNode = newNode;\n      }\n    }\n    currentNode.node = file;\n  }\n\n  if (process.env.NODE_ENV !== \"production\") {\n    assertDeprecatedFormat(tree);\n  }\n\n  return tree;\n}\n\nfunction assertDeprecatedFormat(tree: TreeNode) {\n  for (const child of tree.children) {\n    if (\n      child.node &&\n      child.children.length &&\n      !child.node.normalizedName.endsWith(\"_layout\")\n    ) {\n      const ext = child.node.contextKey.split(\".\").pop();\n      throw new Error(\n        `Using deprecated Layout Route format: Move \\`./app/${child.node.normalizedName}.${ext}\\` to \\`./app/${child.node.normalizedName}/_layout.${ext}\\``\n      );\n    }\n    assertDeprecatedFormat(child);\n  }\n}\n\nfunction getTreeNodesAsRouteNodes(nodes: TreeNode[]): RouteNode[] {\n  return nodes\n    .map((node) => treeNodeToRouteNode(node))\n    .flat()\n    .filter(Boolean) as RouteNode[];\n}\n\nexport function generateDynamicFromSegment(\n  name: string\n): DynamicConvention | null {\n  const deepDynamicName = matchDeepDynamicRouteName(name);\n  const dynamicName = deepDynamicName ?? matchDynamicName(name);\n\n  return dynamicName ? { name: dynamicName, deep: !!deepDynamicName } : null;\n}\n\nexport function generateDynamic(name: string): RouteNode[\"dynamic\"] {\n  const description = name\n    .split(\"/\")\n    .map((segment) => generateDynamicFromSegment(segment))\n    .filter(Boolean) as DynamicConvention[];\n  return description.length === 0 ? null : description;\n}\n\nfunction collapseRouteSegments(route: string) {\n  return stripGroupSegmentsFromPath(route.replace(/\\/index$/, \"\"));\n}\n\n/**\n * Given a route node and a name representing the group name,\n * find the nearest child matching the name.\n *\n * Doesn't support slashes in the name.\n * Routes like `explore/(something)/index` will be matched against `explore`.\n *\n */\nfunction getDefaultInitialRoute(node: RouteNode, name: string) {\n  return node.children.find(\n    (node) => collapseRouteSegments(node.route) === name\n  );\n}\n\nfunction applyDefaultInitialRouteName(node: RouteNode): RouteNode {\n  const groupName = matchGroupName(node.route);\n  if (!node.children?.length) {\n    return node;\n  }\n\n  // Guess at the initial route based on the group name.\n  // TODO(EvanBacon): Perhaps we should attempt to warn when the group doesn't match any child routes.\n  let initialRouteName = groupName\n    ? getDefaultInitialRoute(node, groupName)?.route\n    : undefined;\n  const loaded = node.loadRoute();\n\n  if (loaded.unstable_settings) {\n    // Allow unstable_settings={ initialRouteName: '...' } to override the default initial route name.\n    initialRouteName =\n      loaded.unstable_settings.initialRouteName ?? initialRouteName;\n\n    if (groupName) {\n      // Allow unstable_settings={ 'custom': { initialRouteName: '...' } } to override the less specific initial route name.\n      const groupSpecificInitialRouteName =\n        loaded.unstable_settings?.[groupName]?.initialRouteName;\n\n      initialRouteName = groupSpecificInitialRouteName ?? initialRouteName;\n    }\n  }\n\n  return {\n    ...node,\n    initialRouteName,\n  };\n}\n\nfunction cloneGroupRoute(\n  node: RouteNode,\n  { name: nextName }: { name: string }\n): RouteNode {\n  const groupName = `(${nextName})`;\n  const parts = node.contextKey.split(\"/\");\n  parts[parts.length - 2] = groupName;\n\n  return {\n    ...node,\n    route: groupName,\n    contextKey: parts.join(\"/\"),\n  };\n}\n\nfunction folderNodeToRouteNode({\n  name,\n  children,\n}: TreeNode): RouteNode[] | null {\n  // Empty folder, skip it.\n  if (!children.length) {\n    return null;\n  }\n\n  // When there's a directory, but no layout route file (with valid export), the child routes won't be grouped.\n  // This pushes all children into the nearest layout route.\n  return getTreeNodesAsRouteNodes(\n    children.map((child) => {\n      return {\n        ...child,\n        name: [name, child.name].filter(Boolean).join(\"/\"),\n      };\n    })\n  );\n}\n\nfunction fileNodeToRouteNode(tree: TreeNode): RouteNode[] | null {\n  const { name, node, children } = tree;\n\n  if (!node) throw new Error(\"node must be defined\");\n\n  const dynamic = generateDynamic(name);\n\n  const groupName = matchGroupName(name);\n  const multiGroup = groupName?.includes(\",\");\n\n  const clones = multiGroup\n    ? groupName!.split(\",\").map((v) => ({ name: v.trim() }))\n    : null;\n\n  // Assert duplicates:\n  if (clones) {\n    const names = new Set<string>();\n    for (const clone of clones) {\n      if (names.has(clone.name)) {\n        throw new Error(\n          `Array syntax cannot contain duplicate group name \"${clone.name}\" in \"${node.contextKey}\".`\n        );\n      }\n      names.add(clone.name);\n    }\n  }\n\n  const output = {\n    loadRoute: node.loadRoute,\n    route: name,\n    contextKey: node.contextKey,\n    children: getTreeNodesAsRouteNodes(children),\n    dynamic,\n  };\n\n  if (Array.isArray(clones)) {\n    return clones.map((clone) =>\n      applyDefaultInitialRouteName(cloneGroupRoute({ ...output }, clone))\n    );\n  }\n\n  return [\n    applyDefaultInitialRouteName({\n      loadRoute: node.loadRoute,\n      route: name,\n      contextKey: node.contextKey,\n      children: getTreeNodesAsRouteNodes(children),\n      dynamic,\n    }),\n  ];\n}\n\nfunction treeNodeToRouteNode(tree: TreeNode): RouteNode[] | null {\n  if (tree.node) {\n    return fileNodeToRouteNode(tree);\n  }\n\n  return folderNodeToRouteNode(tree);\n}\n\nfunction contextModuleToFileNodes(\n  contextModule: RequireContext,\n  files: string[] = contextModule.keys()\n): FileNode[] {\n  const nodes = files.map((key) => {\n    // In development, check if the file exports a default component\n    // this helps keep things snappy when creating files. In production we load all screens lazily.\n    try {\n      if (process.env.NODE_ENV === \"development\") {\n        // If the user has set the `EXPO_ROUTER_IMPORT_MODE` to `sync` then we should\n        // filter the missing routes.\n        if (process.env.EXPO_ROUTER_IMPORT_MODE === \"sync\") {\n          if (!contextModule(key)?.default) {\n            return null;\n          }\n        }\n      }\n      const node: FileNode = {\n        loadRoute() {\n          return contextModule(key);\n        },\n        normalizedName: getNameFromFilePath(key),\n        contextKey: key,\n      };\n\n      return node;\n    } catch (error) {\n      // Probably this won't stop metro from freaking out but it's worth a try.\n      console.warn('Error loading route \"' + key + '\"', error);\n    }\n    return null;\n  });\n\n  return nodes.filter(Boolean) as FileNode[];\n}\n\nfunction hasCustomRootLayoutNode(routes: RouteNode[]) {\n  if (routes.length !== 1) {\n    return false;\n  }\n  // This could either be the root _layout or an app with a single file.\n  const route = routes[0];\n\n  if (\n    route.route === \"\" &&\n    route.contextKey.match(/^\\.\\/_layout\\.([jt]sx?)$/)\n  ) {\n    return true;\n  }\n  return false;\n}\n\nfunction treeNodesToRootRoute(treeNode: TreeNode): RouteNode | null {\n  const routes = treeNodeToRouteNode(treeNode);\n  return withOptionalRootLayout(routes);\n}\n\nfunction processKeys(files: string[], options: Options): string[] {\n  const { ignore } = options;\n\n  return files.filter((file) => {\n    return !ignore?.some((pattern) => pattern.test(file));\n  });\n}\n\n/**\n * Asserts if the require.context has files that share the same name but have different extensions. Exposed for testing.\n * @private\n */\nexport function assertDuplicateRoutes(filenames: string[]) {\n  if (process.env.NODE_ENV === \"production\") {\n    return;\n  }\n\n  const duplicates = filenames\n    .map((filename) => removeSupportedExtensions(filename))\n    .reduce((acc, filename) => {\n      acc[filename] = acc[filename] ? acc[filename] + 1 : 1;\n      return acc;\n    }, {} as Record<string, number>);\n\n  Object.entries(duplicates).forEach(([filename, count]) => {\n    if (count > 1) {\n      throw new Error(`Multiple files match the route name \"${filename}\".`);\n    }\n  });\n}\n\n/** Given a Metro context module, return an array of nested routes. */\nexport function getRoutes(\n  contextModule: RequireContext,\n  options?: Options\n): RouteNode | null {\n  const route = getExactRoutes(contextModule, options);\n  if (!route) {\n    return null;\n  }\n\n  appendSitemapRoute(route);\n\n  // Auto add not found route if it doesn't exist\n  appendUnmatchedRoute(route);\n\n  return route;\n}\n\nexport async function getRoutesAsync(\n  contextModule: RequireContext,\n  options?: Options\n): Promise<RouteNode | null> {\n  const route = await getExactRoutesAsync(contextModule, options);\n  if (!route) {\n    return null;\n  }\n\n  appendSitemapRoute(route);\n\n  // Auto add not found route if it doesn't exist\n  appendUnmatchedRoute(route);\n\n  return route;\n}\n\nfunction getIgnoreList(options?: Options) {\n  const ignore: RegExp[] = [\n    /^\\.\\/\\+html\\.[tj]sx?$/,\n    ...(options?.ignore ?? []),\n  ];\n  return ignore;\n}\n\n/** Get routes without unmatched or sitemap. */\nexport function getExactRoutes(\n  contextModule: RequireContext,\n  options?: Options\n): RouteNode | null {\n  const treeNodes = contextModuleToTree(contextModule, options);\n  const route = treeNodesToRootRoute(treeNodes);\n  return route || null;\n}\n\nfunction contextModuleToTree(contextModule: RequireContext, options?: Options) {\n  const allowed = processKeys(contextModule.keys(), {\n    ...options,\n    ignore: getIgnoreList(options),\n  });\n  assertDuplicateRoutes(allowed);\n  const files = contextModuleToFileNodes(contextModule, allowed);\n  return getRecursiveTree(files);\n}\n\nexport async function getExactRoutesAsync(\n  contextModule: RequireContext,\n  options?: Options\n): Promise<RouteNode | null> {\n  const treeNodes = contextModuleToTree(contextModule, options);\n  const route = treeNodesToRootRoute(treeNodes);\n  return route || null;\n}\n\nfunction appendSitemapRoute(routes: RouteNode) {\n  if (\n    !routes.children.length ||\n    // Allow overriding the sitemap route\n    routes.children.some((route) => route.route === \"_sitemap\")\n  ) {\n    return routes;\n  }\n  const { Sitemap, getNavOptions } = require(\"./views/Sitemap\");\n  routes.children.push({\n    loadRoute() {\n      return { default: Sitemap, getNavOptions };\n    },\n    route: \"_sitemap\",\n    contextKey: \"./_sitemap.tsx\",\n    generated: true,\n    internal: true,\n    dynamic: null,\n    children: [],\n  });\n  return routes;\n}\n\nfunction appendUnmatchedRoute(routes: RouteNode) {\n  // Auto add not found route if it doesn't exist\n  const userDefinedDynamicRoute = getUserDefinedDeepDynamicRoute(routes);\n  if (!userDefinedDynamicRoute) {\n    routes.children.push({\n      loadRoute() {\n        return { default: require(\"./views/Unmatched\").Unmatched };\n      },\n      route: \"[...404]\",\n      contextKey: \"./[...404].tsx\",\n      dynamic: [{ name: \"404\", deep: true }],\n      children: [],\n      generated: true,\n      internal: true,\n    });\n  }\n  return routes;\n}\n\n/**\n * Exposed for testing.\n * @returns a top-level deep dynamic route if it exists, otherwise null.\n */\nexport function getUserDefinedDeepDynamicRoute(\n  routes: RouteNode\n): RouteNode | null {\n  // Auto add not found route if it doesn't exist\n  for (const route of routes.children ?? []) {\n    if (route.generated) continue;\n    const opaqueRoute = stripInvisibleSegmentsFromPath(route.route);\n    const isDeepDynamic = matchDeepDynamicRouteName(opaqueRoute);\n    if (isDeepDynamic) {\n      return route;\n    }\n    // Recurse through group routes\n    if (matchGroupName(route.route)) {\n      const child = getUserDefinedDeepDynamicRoute(route);\n      if (child) {\n        return child;\n      }\n    }\n  }\n  return null;\n}\n\nfunction withOptionalRootLayout(routes: RouteNode[] | null): RouteNode | null {\n  if (!routes?.length) {\n    return null;\n  }\n\n  if (hasCustomRootLayoutNode(routes)) {\n    return routes[0];\n  }\n\n  return {\n    loadRoute: () => ({\n      default: (\n        require(\"./views/Navigator\") as typeof import(\"./views/Navigator\")\n      ).DefaultNavigator,\n    }),\n    // Generate a fake file name for the directory\n    contextKey: \"./_layout.tsx\",\n    route: \"\",\n    generated: true,\n    dynamic: null,\n    children: routes,\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}