{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nexport var resolveHref = function resolveHref(href) {\n  var _href$pathname;\n  if (typeof href === \"string\") {\n    return resolveHref({\n      pathname: href != null ? href : \"\"\n    });\n  }\n  var path = (_href$pathname = href.pathname) != null ? _href$pathname : \"\";\n  if (!(href != null && href.params)) {\n    return path;\n  }\n  var _createQualifiedPathn = createQualifiedPathname(path, _objectSpread({}, href.params)),\n    pathname = _createQualifiedPathn.pathname,\n    params = _createQualifiedPathn.params;\n  return pathname + (Object.keys(params).length ? \"?\" + createQueryParams(params) : \"\");\n};\nfunction createQualifiedPathname(pathname, params) {\n  for (var _ref of Object.entries(params)) {\n    var _ref2 = _slicedToArray(_ref, 2);\n    var key = _ref2[0];\n    var _ref2$ = _ref2[1];\n    var value = _ref2$ === void 0 ? \"\" : _ref2$;\n    var dynamicKey = \"[\" + key + \"]\";\n    var deepDynamicKey = \"[...\" + key + \"]\";\n    if (pathname.includes(dynamicKey)) {\n      pathname = pathname.replace(dynamicKey, Array.isArray(value) ? value.join(\"/\") : value);\n    } else if (pathname.includes(deepDynamicKey)) {\n      pathname = pathname.replace(deepDynamicKey, Array.isArray(value) ? value.join(\"/\") : value);\n    } else {\n      continue;\n    }\n    delete params[key];\n  }\n  return {\n    pathname: pathname,\n    params: params\n  };\n}\nfunction createQueryParams(params) {\n  return Object.entries(params).map(function (props) {\n    return props.join(\"=\");\n  }).join(\"&\");\n}","map":{"version":3,"names":["resolveHref","href","_href$pathname","pathname","path","params","_createQualifiedPathn","createQualifiedPathname","_objectSpread","Object","keys","length","createQueryParams","_ref","entries","_ref2","_slicedToArray","key","_ref2$","value","dynamicKey","deepDynamicKey","includes","replace","Array","isArray","join","map","props"],"sources":["/home/martz/GitHub/react-expo-router/NavTabs/node_modules/expo-router/src/link/href.ts"],"sourcesContent":["export type Href = string | HrefObject;\n\nexport interface HrefObject {\n  /** Path representing the selected route `/[id]`. */\n  pathname?: string;\n  /** Query parameters for the path. */\n  params?: Record<string, any>;\n}\n\n/** Resolve an href object into a fully qualified, relative href. */\nexport const resolveHref = (href: Href): string => {\n  if (typeof href === \"string\") {\n    return resolveHref({ pathname: href ?? \"\" });\n  }\n  const path = href.pathname ?? \"\";\n  if (!href?.params) {\n    return path;\n  }\n  const { pathname, params } = createQualifiedPathname(path, {\n    ...href.params,\n  });\n  return (\n    pathname +\n    (Object.keys(params).length ? `?${createQueryParams(params)}` : \"\")\n  );\n};\n\nfunction createQualifiedPathname(\n  pathname: string,\n  params: Record<string, any>\n): Omit<Required<HrefObject>, \"query\"> {\n  for (const [key, value = \"\"] of Object.entries(params)) {\n    const dynamicKey = `[${key}]`;\n    const deepDynamicKey = `[...${key}]`;\n    if (pathname.includes(dynamicKey)) {\n      pathname = pathname.replace(\n        dynamicKey,\n        Array.isArray(value) ? value.join(\"/\") : value\n      );\n    } else if (pathname.includes(deepDynamicKey)) {\n      pathname = pathname.replace(\n        deepDynamicKey,\n        Array.isArray(value) ? value.join(\"/\") : value\n      );\n    } else {\n      continue;\n    }\n\n    delete params[key];\n  }\n  return { pathname, params };\n}\n\nfunction createQueryParams(params: Record<string, any>): string {\n  return Object.entries(params)\n    .map((props) => props.join(\"=\"))\n    .join(\"&\");\n}\n"],"mappings":";;;;AAUA,OAAO,IAAMA,WAAW,GAAG,SAAdA,WAAWA,CAAIC,IAAU,EAAa;EAAA,IAAAC,cAAA;EACjD,IAAI,OAAOD,IAAI,KAAK,QAAQ,EAAE;IAC5B,OAAOD,WAAW,CAAC;MAAEG,QAAQ,EAAEF,IAAI,WAAJA,IAAI,GAAI;IAAG,CAAC,CAAC;EAC9C;EACA,IAAMG,IAAI,IAAAF,cAAA,GAAGD,IAAI,CAACE,QAAQ,YAAAD,cAAA,GAAI,EAAE;EAChC,IAAI,EAACD,IAAI,YAAJA,IAAI,CAAEI,MAAM,GAAE;IACjB,OAAOD,IAAI;EACb;EACA,IAAAE,qBAAA,GAA6BC,uBAAuB,CAACH,IAAI,EAAAI,aAAA,KACpDP,IAAI,CAACI,MAAM,CACf,CAAC;IAFMF,QAAQ,GAAAG,qBAAA,CAARH,QAAQ;IAAEE,MAAM,GAAAC,qBAAA,CAAND,MAAM;EAGxB,OACEF,QAAQ,IACPM,MAAM,CAACC,IAAI,CAACL,MAAM,CAAC,CAACM,MAAM,SAAOC,iBAAiB,CAACP,MAAM,CAAC,GAAK,EAAE,CAAC;AAEvE,CAAC;AAED,SAASE,uBAAuBA,CAC9BJ,QAAgB,EAChBE,MAA2B,EACU;EACrC,SAAAQ,IAAA,IAAgCJ,MAAM,CAACK,OAAO,CAACT,MAAM,CAAC,EAAE;IAAA,IAAAU,KAAA,GAAAC,cAAA,CAAAH,IAAA;IAAA,IAA5CI,GAAG,GAAAF,KAAA;IAAA,IAAAG,MAAA,GAAAH,KAAA;IAAA,IAAEI,KAAK,GAAAD,MAAA,cAAG,EAAE,GAAAA,MAAA;IACzB,IAAME,UAAU,SAAOH,GAAG,MAAG;IAC7B,IAAMI,cAAc,YAAUJ,GAAG,MAAG;IACpC,IAAId,QAAQ,CAACmB,QAAQ,CAACF,UAAU,CAAC,EAAE;MACjCjB,QAAQ,GAAGA,QAAQ,CAACoB,OAAO,CACzBH,UAAU,EACVI,KAAK,CAACC,OAAO,CAACN,KAAK,CAAC,GAAGA,KAAK,CAACO,IAAI,CAAC,GAAG,CAAC,GAAGP,KAC3C,CAAC;IACH,CAAC,MAAM,IAAIhB,QAAQ,CAACmB,QAAQ,CAACD,cAAc,CAAC,EAAE;MAC5ClB,QAAQ,GAAGA,QAAQ,CAACoB,OAAO,CACzBF,cAAc,EACdG,KAAK,CAACC,OAAO,CAACN,KAAK,CAAC,GAAGA,KAAK,CAACO,IAAI,CAAC,GAAG,CAAC,GAAGP,KAC3C,CAAC;IACH,CAAC,MAAM;MACL;IACF;IAEA,OAAOd,MAAM,CAACY,GAAG,CAAC;EACpB;EACA,OAAO;IAAEd,QAAQ,EAARA,QAAQ;IAAEE,MAAM,EAANA;EAAO,CAAC;AAC7B;AAEA,SAASO,iBAAiBA,CAACP,MAA2B,EAAU;EAC9D,OAAOI,MAAM,CAACK,OAAO,CAACT,MAAM,CAAC,CAC1BsB,GAAG,CAAC,UAACC,KAAK;IAAA,OAAKA,KAAK,CAACF,IAAI,CAAC,GAAG,CAAC;EAAA,EAAC,CAC/BA,IAAI,CAAC,GAAG,CAAC;AACd"},"metadata":{},"sourceType":"module","externalDependencies":[]}