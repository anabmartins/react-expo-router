{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nimport { CommonActions, getActionFromState, NavigationContainerRefContext, StackActions } from \"@react-navigation/core\";\nimport { TabActions } from \"@react-navigation/routers\";\nimport * as Linking from \"expo-linking\";\nimport * as React from \"react\";\nimport { resolve } from \"./path\";\nimport { findTopRouteForTarget, getEarliestMismatchedRoute, getQualifiedStateForTopOfTargetState, isMovingToSiblingRoute } from \"./stateOperations\";\nimport { useLinkingContext } from \"./useLinkingContext\";\nfunction isRemoteHref(href) {\n  return /:\\/\\//.test(href);\n}\nexport function useLinkToPath() {\n  var navigation = React.useContext(NavigationContainerRefContext);\n  var linking = useLinkingContext();\n  var linkTo = React.useCallback(function (href, event) {\n    if (isRemoteHref(href)) {\n      Linking.openURL(href);\n      return;\n    }\n    if (navigation == null) {\n      throw new Error(\"Couldn't find a navigation object. Is your component inside NavigationContainer?\");\n    }\n    if (href === \"..\" || href === \"../\") {\n      navigation.goBack();\n      return;\n    }\n    if (href.startsWith(\".\")) {\n      var base = linking.getPathFromState == null ? void 0 : linking.getPathFromState(navigation.getRootState(), _objectSpread(_objectSpread({}, linking.config), {}, {\n        preserveGroups: true\n      }));\n      if (base && !base.endsWith(\"/\")) {\n        base += \"/..\";\n      }\n      href = resolve(base, href);\n    }\n    var state = linking.getStateFromPath(href, linking.config);\n    if (!state) {\n      console.error(\"Could not generate a valid navigation state for the given path: \" + href);\n      return;\n    }\n    var rootState = navigation.getRootState();\n    if (isMovingToSiblingRoute(rootState, state)) {\n      var knownOwnerState = getQualifiedStateForTopOfTargetState(rootState, state);\n      var nextRoute = findTopRouteForTarget(state);\n      if (knownOwnerState.type === \"tab\") {\n        navigation.dispatch(TabActions.jumpTo(nextRoute.name, nextRoute.params));\n        return;\n      } else {\n        if (event === \"REPLACE\") {\n          navigation.dispatch(StackActions.replace(nextRoute.name, nextRoute.params));\n        } else {\n          navigation.dispatch(CommonActions.navigate(nextRoute.name, nextRoute.params));\n        }\n        return;\n      }\n    }\n    var action = getActionFromState(state, linking.config);\n    if (action) {\n      if (event === \"REPLACE\" && isAbsoluteInitialRoute(action)) {\n        var earliest = getEarliestMismatchedRoute(rootState, action.payload);\n        if (earliest) {\n          if (earliest.type === \"stack\") {\n            navigation.dispatch(StackActions.replace(earliest.name, earliest.params));\n          } else {\n            navigation.dispatch(TabActions.jumpTo(earliest.name, earliest.params));\n          }\n          return;\n        } else {}\n      }\n      navigation.dispatch(action);\n    } else {\n      navigation.reset(state);\n    }\n  }, [linking, navigation]);\n  return linkTo;\n}\nexport function isAbsoluteInitialRoute(action) {\n  if ((action == null ? void 0 : action.type) !== \"NAVIGATE\") {\n    return false;\n  }\n  var next = action.payload.params;\n  while (next) {\n    if (!isNavigationState(next)) {\n      return false;\n    }\n    if (next.initial === true) {\n      next = next.params;\n    } else if (next.initial === false) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction isNavigationState(obj) {\n  return \"initial\" in obj;\n}","map":{"version":3,"names":["CommonActions","getActionFromState","NavigationContainerRefContext","StackActions","TabActions","Linking","React","resolve","findTopRouteForTarget","getEarliestMismatchedRoute","getQualifiedStateForTopOfTargetState","isMovingToSiblingRoute","useLinkingContext","isRemoteHref","href","test","useLinkToPath","navigation","useContext","linking","linkTo","useCallback","event","openURL","Error","goBack","startsWith","base","getPathFromState","getRootState","_objectSpread","config","preserveGroups","endsWith","state","getStateFromPath","console","error","rootState","knownOwnerState","nextRoute","type","dispatch","jumpTo","name","params","replace","navigate","action","isAbsoluteInitialRoute","earliest","payload","reset","next","isNavigationState","initial","obj"],"sources":["/home/martz/GitHub/react-expo-router/NavTabs/node_modules/expo-router/src/link/useLinkToPath.ts"],"sourcesContent":["import {\n  CommonActions,\n  getActionFromState,\n  NavigationContainerRefContext,\n  StackActions,\n} from \"@react-navigation/core\";\nimport { TabActions } from \"@react-navigation/routers\";\nimport * as Linking from \"expo-linking\";\nimport * as React from \"react\";\n\nimport { resolve } from \"./path\";\nimport {\n  findTopRouteForTarget,\n  getEarliestMismatchedRoute,\n  getQualifiedStateForTopOfTargetState,\n  isMovingToSiblingRoute,\n  NavigateAction,\n} from \"./stateOperations\";\nimport { useLinkingContext } from \"./useLinkingContext\";\n\ntype NavStateParams = {\n  params?: NavStateParams;\n  path: string;\n  initial: boolean;\n  screen: string;\n  state: unknown;\n};\n\nfunction isRemoteHref(href: string): boolean {\n  return /:\\/\\//.test(href);\n}\n\nexport function useLinkToPath() {\n  const navigation = React.useContext(NavigationContainerRefContext);\n  const linking = useLinkingContext();\n\n  const linkTo = React.useCallback(\n    (href: string, event?: string) => {\n      if (isRemoteHref(href)) {\n        Linking.openURL(href);\n        return;\n      }\n\n      if (navigation == null) {\n        throw new Error(\n          \"Couldn't find a navigation object. Is your component inside NavigationContainer?\"\n        );\n      }\n\n      if (href === \"..\" || href === \"../\") {\n        navigation.goBack();\n        return;\n      }\n\n      if (href.startsWith(\".\")) {\n        let base = linking.getPathFromState?.(navigation.getRootState(), {\n          ...linking.config,\n          preserveGroups: true,\n        });\n\n        if (base && !base.endsWith(\"/\")) {\n          base += \"/..\";\n        }\n        href = resolve(base, href);\n      }\n\n      const state = linking.getStateFromPath!(href, linking!.config);\n\n      if (!state) {\n        console.error(\n          \"Could not generate a valid navigation state for the given path: \" +\n            href\n        );\n        return;\n      }\n\n      const rootState = navigation.getRootState();\n\n      // Ensure simple operations are used when moving between siblings\n      // in the same navigator. This ensures that the state is not reset.\n      // TODO: We may need to apply this at a larger scale in the future.\n      if (isMovingToSiblingRoute(rootState, state)) {\n        // Can perform naive movements\n        const knownOwnerState = getQualifiedStateForTopOfTargetState(\n          rootState,\n          state\n        )!;\n        const nextRoute = findTopRouteForTarget(state);\n\n        if (knownOwnerState.type === \"tab\") {\n          navigation.dispatch(\n            TabActions.jumpTo(nextRoute.name, nextRoute.params)\n          );\n          return;\n        } else {\n          if (event === \"REPLACE\") {\n            navigation.dispatch(\n              StackActions.replace(nextRoute.name, nextRoute.params)\n            );\n          } else {\n            // NOTE: Not sure if we should pop or push here...\n            navigation.dispatch(\n              CommonActions.navigate(nextRoute.name, nextRoute.params)\n            );\n          }\n          return;\n        }\n      }\n\n      // TODO: Advanced movements across multiple navigators\n\n      const action = getActionFromState(state, linking!.config);\n      if (action) {\n        // Here we have a navigation action to a nested screen, where we should ideally replace.\n        // This request can only be fulfilled if the target is an initial route.\n        // First, check if the action is fully initial routes.\n        // Then find the nearest mismatched route in the existing state.\n        // Finally, use the correct navigator-based action to replace the nested screens.\n        // NOTE(EvanBacon): A future version of this will involve splitting the navigation request so we replace as much as possible, then push the remaining screens to fulfill the request.\n        if (event === \"REPLACE\" && isAbsoluteInitialRoute(action)) {\n          const earliest = getEarliestMismatchedRoute(\n            rootState,\n            action.payload\n          );\n          if (earliest) {\n            if (earliest.type === \"stack\") {\n              navigation.dispatch(\n                StackActions.replace(earliest.name, earliest.params)\n              );\n            } else {\n              navigation.dispatch(\n                TabActions.jumpTo(earliest.name, earliest.params)\n              );\n            }\n            return;\n          } else {\n            // This should never happen because moving to the same route would be handled earlier\n            // in the sibling operations.\n          }\n        }\n\n        // Ignore the replace event here since replace across\n        // navigators is not supported.\n        navigation.dispatch(action);\n      } else {\n        navigation.reset(state);\n      }\n    },\n    [linking, navigation]\n  );\n\n  return linkTo;\n}\n\n/** @returns `true` if the action is moving to the first screen of all the navigators in the action. */\nexport function isAbsoluteInitialRoute(\n  action: ReturnType<typeof getActionFromState>\n): action is NavigateAction {\n  if (action?.type !== \"NAVIGATE\") {\n    return false;\n  }\n\n  let next = action.payload.params;\n  // iterate all child screens and bail out if any are not initial.\n  while (next) {\n    if (!isNavigationState(next)) {\n      // Not sure when this would happen\n      return false;\n    }\n    if (next.initial === true) {\n      next = next.params;\n      // return true;\n    } else if (next.initial === false) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction isNavigationState(obj: any): obj is NavStateParams {\n  return \"initial\" in obj;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}